= Customize the Connector's Sample Data
ifndef::env-site,env-github[]
include::../_attributes.adoc[]
endif::[]

Configure and customize sample data of the connector descriptor of the connector.

Sample data resolvers provide an example of the output of an operation. Sample data
resolvers show the data structure as well as a real example of that structure and sample values
for each field. Sample data resolvers can be applied to operations (paged or not)
and triggers.

The following example shows how sample data is displayed:

image::sample-data-output.png[alt=Sample Data Output,width=165,height=500]

== Definition of a Sample Data Resolver

There are two types of sample data resolvers.

* HTTP Request
+
Defines a custom HTTP request and transforms its result to generate the sample data

* Same Operation
+
Replicates the request and transforms the operation or trigger to generate the sample data

== HTTP Request Sample Data Resolver

An HTTP request sample data resolver contains two elements: a request and an optional transformation of that request's result.

The `request` node is an <<../rest-sdk/data-expressions.adoc#HTTP Request, HTTP Request Data Expression>>. It is used to make a request to the server where the sample data must be obtained from.

The `transform` node describes how the server response is manipulated to generate the sample data. This transformation is optional and can be omitted if the server response matches the output of the operation or trigger.
The transform expression has access to the `payload` and `attributes` variables, which contain the server response body and the server response attributes respectively.

The following example shows an HTTP request sample data resolver:

[source, yaml]
----
triggers:
  onNewFlightInline:
    displayName: On New Flight Inline
    path: /flight/since/{flightId}
    method: get

    items:
      extraction:
        expression: "#[payload.flights]"

    #[...]

    sampleData:
      type: http
      request:
        path: /flight/since/2021-01-01
        method: get
      transform:
        language: "dataweave"
        expression: "#[payload.flights[0]]"

----

This example shows the implementation of the sample data for a trigger.

This trigger polls for new flights on the `/flight/since/{flightId}` endpoint. The
sample data definition makes a request to `/flight/since/2021-01-01` to get a
list of flights, and then uses the `"#[payload.flights[0]]"` expression to
extract the first item from the results. It replicates a result from the trigger,
as triggers propagate the response items one by one.

== Same Operation Sample Data Resolver 

Same operation definitions are the easiest way to replicate the operation or trigger
behavior to get sample data. Using the same operation definition requires declaration only since
REST SDK handles the generation.

The following example shows a same operation sample data resolver:

[source, yaml]
----
triggers:
  onNewFlightInline:
    displayName: On New Flight Inline
    path: /flight/since/{flightId}
    method: get

    items:
      extraction:
        expression: "#[payload.flights]"

    #[...]

    sampleData:
      type: sameOperation
----

This example shows that implementing the same operation sample data consists of one line of yaml.

This implementation sends a request to the operation or trigger path `/flight/since/{flightId}`
using the `flightId` parameter that the user fills in the UI. It then transforms the
server response using the trigger item extraction expression `"#[payload.flights]"` and
gets the first result from that array to show as a sample.

== Reusability

Similar to other resolvers, sample data resolvers can be declared locally (inline) or globally. When declared globally, they can be referenced multiple times from the different places they are used in.

=== Inline Declaration

Inline definitions are useful for shorter connector descriptors that do not
require reusability.

Inline definitions have access to the `queryParameter`, `uriParameter`, and
`header` variables, which are maps that contain the respective parameters
declared in the operation. Inline definitions can also access the `body` variable
to access fields inside the body parameter.

Inline definitions in triggers have access to the `parameters` variable, which
contain all the parameters declared in the trigger.

The following example shows a definition of an inline sample data resolver:

[source, yaml]
----
endpoints:
  /conversations.list:
    operations:
      get:
        sampleData:
          type: http
          request:
            path: /conversations.list
            method: get
            binding:
              queryParameter:
                channelType: "#[queryParameter.types]"
          transform:
            language: "dataweave"
            expression: "#[payload.channels[0]]"
----

This inline sample data resolver sends a `GET` request to the /conversations.list
endpoint and extracts the first channel from the response. The declaration has
access to the operation context, so it can access the `queryParameter.types`
parameter from the operation to use it as a binding for the HTTP request.

=== Global Declaration

Global definitions provide reuse capabilities. A globally declared sample data resolver
enables defining parameters to build a context of where it can be executed.

The following example shows a definition of a global sample data resolver:

[source, yaml]
----
sampleData:
  sampleConversation:
    parameters:
      conversationType:
        type: string
    definition:
      request:
        path: /conversations.list
        method: get
        binding:
          queryParameter:
            channelType: "#[parameter.conversationType]"
      transform:
        language: "dataweave"
        expression: "#[payload.channels[0]]"

endpoints:
  /conversations.list:
    operations:
      get:
        sampleData:
          type: reference
          id: sampleConversation
          arguments:
            conversationType:
              value: queryParameter.types
----

Since this sample data resolver is declared globally, it does not have access to the
operation parameters. Instead, it declares a parameter that the
referer operation passes a value onto.

A `conversationType` parameter is declared in the `parameters` section of the global
declaration. A value is assigned to it in the `arguments` section of the sample
data reference. It is then used in the HTTP request binding using the
`parameters` variable. All of the declared parameters are present in that map.

When assigning values, it is also possible to access fields from `body`. The following
example shows how to access a field *channelId* that is assigned as a parameter for the resolver:

[source, yaml]
----
endpoints:
  /conversations.list:
    operations:
      get:
        sampleData:
          type: reference
          id: sampleConversation
          arguments:
            channel:
              value: body.content.channelId
----

The value used to access fields inside the `body` uses DataWeave accessors
and is valid for the input metadata type defined for the `body` parameter.
